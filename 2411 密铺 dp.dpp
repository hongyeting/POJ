//超时做法

#include<iostream>

using namespace std;

bool p[11][12];
bool mem[12][2048][2048];
/*
	前y-1行满，y+2及以后全空的情况下，y和y+1行的状态
	=前b-y-1行满，b-y+1及以后全空时，b-y和b-y-1行的状态
*/
const int dx[2] = { 1,0 }, dy[2] = { 0,1 };
int ans, a, b;

void f(int x, int y) {
	while (p[x][y]) {
		if (x < a - 1)x++;
		else if (y < b - 1) {
			y++;x = 0;
		}
		else {
			ans++;return;
		}
	}
	int m[2] = { 0 };
	for (int i = 0;i < a;i++) {
		if (p[i][y])m[0] = m[0] | 1 << i;
		if (p[i][y + 1])m[1] = m[1] | 1 << i;
	}
	if (mem[y][m[0]][m[1]])return;
	int t = ans;
	for (int dir = 0;dir < 2;dir++) {
		int fx = x + dx[dir], fy = y + dy[dir];
		if (fx < a && fy < b && !p[fx][fy]) {
			if (mem[y][m[0]][m[1]])return;
			int cx = dir == 0 ? m[0] | (3 << x) : m[0] | (1 << x), cy = dir == 0 ? m[1] : m[1] | (1 << x);
			p[x][y] = true;p[fx][fy] = true;
			int s = ans;
			f(x, y);
			if (s == ans)mem[y][cx][cy] = true;
			p[x][y] = false;p[fx][fy] = false;
		}
	}
	if (ans == t)mem[y][m[0]][m[1]] = true;
	return;
}

int main() {
	while (true) {
		cin >> a >> b;
		if (a == 0)break;
		if (a & 1 && b & 1) {
			cout << 0 << '\n';
		}
		else {
			memset(p, 0, sizeof(p));
			memset(mem, 0, sizeof(mem));
			ans = 0;
			f(0, 0);
			cout << ans << '\n';
		}
	}
	return 0;
}
